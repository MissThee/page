我们知道Java 进行GC的时候会从GC root进行可达性判断，常见的GC Root有如下：

通过System Class Loader或者Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root
处于激活状态的线程
栈中的对象
JNI栈中的对象
JNI中的全局对象
正在被用于同步的各种锁对象
JVM自身持有的对象，比如系统类加载器等。

在调查内存泄漏原因的时候可以根据GC Root来推导
了解了这些，我们来看一下常用的GC算法

标记回收算法
从GC root进行遍历，把可达对象都标记，剩下那些不可达的进行回收，这种方式需要中断其他线程，并且可能产生内存碎片
复制算法
把内存区域分为两块，每次使用一块，GC的时候把一块中的内容移动到另一块中，原始内存中的对象就可以被回收了。
标记压缩算法
和标记回收差不多，但是在回收的时候会对可达对象进行整理，将其压缩到内存的一段，避免内存碎片
分代算法
将内存区域分代，对不同的代使用不同的回收算法，通常分为新生代，老年代，和永久带。
新生代一般包含三个区域，Eden区和两个Survivor区，新生代一般采用复制算法

老年代一般采用标记压缩算法
永久带一般是方法区，JVM规范并没有强制要求说必须要回收这个区域。
在Dalvik虚拟机中的堆其实是分为了两个，一个是Zygote堆，一个是Active堆，Zygote堆中主要是预加载的各种资源和对象，这个堆很少被写。我们分配的堆内存一般都是在Activie堆进行分配的。

